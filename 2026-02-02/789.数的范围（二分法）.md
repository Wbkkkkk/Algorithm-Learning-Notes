# 二分法
单调序列一定可以二分，但可以二分的不必须是单调序列。\
只要该序列的前段和后端可以由一个性质进行分割，就可以通过二分法找到这个分界点。
## 二分法模板1
```
while(l<r){
    int mid=l+r+1>>1;
    if(check())  l=mid;
    else  r=mid-1;
}
```
因为c++语法中，除以2是下取整，所以l=mid中的mid可能会等于l，导致l=l，进入死循环。
## 二分法模板2
```
while(l<r){
    int mid=l+r>>1;
    if(check())  r=mid;
    else  l=mid+1;
}
```
需要注意，mid的值是需要在循环中更新的，不然也是死循环。
# 789.数的范围
## 处理方法1
```
int search_l(int array[],int l,int r,int target){
    if(array[l]==target)  return l;
    
    while(l<r){
        int mid=(l+r+1)/2;
        if(array[mid]<target)  l=mid;
        else r=mid-1;
    }
    if(array[r+1]!=target) return -1;
    return r+1;
}

int search_r(int array[],int l,int r,int target){
    if(array[r]==target)  return r;
    
    while(l<r){
        int mid=(l+r)/2;
        if(array[mid]>target) r=mid;
        else l=mid+1;
    }
    if(array[l-1]!=target) return -1;
    return l-1;
}
```
注意，在找左边界的时候，考虑如果整个数组的最小值恰好是左边界；在找右边界的时候，考虑如果整个数组的最大值恰好是右边界。
## 处理方法2
```
int search_l(int array[],int l,int r,int target){
    while(l<r){
        int mid=(l+r)/2;
        if(array[mid]>=target)  r=mid;
        else l=mid+1;
    }
    if(array[r]!=target) return -1;
    else return r;
}

int search_r(int array[],int l,int r,int target){
    while(l<r){
        int mid=(l+r+1)/2;
        if(array[mid]<=target) l=mid;
        else r=mid-1;
    }
    if(array[l]!=target) return -1;
    else return l;
}
```
注意while的循环条件是l<r，所以最后，`l=r`，l和r都表示最后找到的边界
