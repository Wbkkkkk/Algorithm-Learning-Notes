# 归并算法
```
void merge_sort(int q[],int l,int r){
    if(l>=r)  return;

    int mid=(l+r)/2;
    merge_sort(q,l,mid),merge_sort(q,mid+1,r);
    //先划分

    int k=0;
    int i=l,j=mid+1;
    while(i<=mid&&j<=r){
        if(q[i]<=q[j])  temp[k++]=q[i++];
        else  temp[k++]=q[j++];
    }
    while(i<=mid)  temp[k++]=q[i++];
    while(j<=r)  temp[k++]=q[j++];
    //再合并

    for(i=l,j=0;i<=r;i++,j++){
        q[i]=temp[j];
    }
    //后赋值
}
```
# 求逆序对儿
利用归并排序，每次q[i]>q[j]时，说明q[i]及其后面的所有元素都大于q[j]，均为逆序对儿，所以设置一个全局flag=0，每次出现q[i]>q[j]，都有mid-i+1个逆序对儿
